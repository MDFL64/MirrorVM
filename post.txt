Month two of no progress on my language -- still distracted by my [absurd .NET reflection-driven compiler](https://sbox.game/churchofmiku/brainflood/news/brainflood-compiling-via-reflection-8089c180).

The webassmebly version is basically functional, but now I'm deep in the process of trying to optimize it. This involves some pretty nasty efforts to abuse the JIT's inlining heuristics, in order to compile each source-function into the smallest number of native functions possible.

Once that's handled, there are two other big tasks: control flow (some relooper-esque attempting to construct C# if's and loop's, where possible, instead of relying on a big dispatch loop) and register allocation (yeah, it has virtual registers, it's a complete disaster, don't worry about it). Then I'll make a second post that actually explains all this insanity in detail.

On the topic of the language I'm neglecting to build, I think this project has sold me on targeting webassembly. Honestly, I don't buy a lot of the hype around webassembly, but:
1. It's ridiculously easy to generate code for.
2. The GC extension looks neat.
3. Building a self-hosting compiler sounds like a fun challenge, which isn't really viable with my old cranelift JIT strategy. I really do want this language to be simple and easy to hack on, and my hope is that these constraints will encourage that.
4. I can use it as a basis for the slightly more niche language I originally wanted to build, or for other unhinged experiments.